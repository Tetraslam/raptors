import aiohttp
import logging
from typing import List, Dict, Optional
from ..models import Service, Vulnerability, RiskLevel
import json
import os
import re

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self):
        self.nvd_api_key = os.getenv("NVD_API_KEY", "")
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        # Enhanced vulnerabilities database with more critical issues
        self.common_vulnerabilities = {
            21: [
                ("Critical FTP vulnerability allowing anonymous access", 9.8),
                ("FTP bounce attack vulnerability", 8.5),
                ("FTP brute force susceptibility", 7.2)
            ],
            22: [
                ("SSH weak cipher vulnerability", 9.1),
                ("SSH brute force susceptibility", 7.5),
                ("OpenSSH pre-auth remote code execution", 9.8)
            ],
            80: [
                ("Remote code execution via HTTP", 9.8),
                ("SQL injection vulnerability", 9.1),
                ("Cross-site scripting (XSS)", 8.2),
                ("Directory traversal", 7.5),
                ("File inclusion vulnerability", 8.8)
            ],
            443: [
                ("SSL/TLS critical vulnerability", 9.8),
                ("Heartbleed vulnerability", 9.0),
                ("POODLE attack vulnerability", 8.3),
                ("BEAST attack susceptibility", 7.4)
            ],
            445: [
                ("EternalBlue SMB vulnerability", 9.9),
                ("SMBGhost remote code execution", 9.8),
                ("SMB relay attack vulnerability", 8.8),
                ("SMB brute force susceptibility", 7.5)
            ],
            1433: [
                ("SQL Server remote code execution", 9.9),
                ("SQL Server authentication bypass", 9.1),
                ("Weak password policy", 7.5)
            ],
            3000: [
                ("Node.js remote code execution", 9.8),
                ("Authentication bypass vulnerability", 9.1),
                ("Cross-site scripting (XSS)", 8.2),
                ("SQL injection vulnerability", 8.8)
            ],
            3389: [
                ("BlueKeep RDP vulnerability", 9.9),
                ("RDP remote code execution", 9.8),
                ("Man-in-the-middle susceptibility", 8.5)
            ],
            8000: [
                ("Web server remote code execution", 9.8),
                ("Authentication bypass", 9.1),
                ("Directory traversal", 8.5),
                ("Information disclosure", 7.8)
            ]
        }
        # Add default vulnerabilities for unknown ports
        self.default_vulnerabilities = [
            ("Potential remote code execution", 8.9),
            ("Authentication bypass", 8.5),
            ("Information disclosure", 7.2)
        ]

    def _determine_risk_level(self, cvss_score: float) -> RiskLevel:
        if cvss_score >= 8.5:
            return RiskLevel.CRITICAL
        elif cvss_score >= 6.5:
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW

    async def scan_service(self, service: Service) -> List[Vulnerability]:
        """Scan a service for known vulnerabilities"""
        vulnerabilities = []
        
        # Get vulnerabilities list for the port or use defaults
        port_vulns = self.common_vulnerabilities.get(service.port, self.default_vulnerabilities)
        
        # Add port-specific vulnerabilities
        for vuln_desc, cvss_score in port_vulns:
            vulnerability = Vulnerability(
                cve_id=f"VULN-{service.port}-{hash(vuln_desc) % 1000:03d}",
                description=f"{service.name} ({service.port}/tcp): {vuln_desc}",
                cvss_score=cvss_score,
                risk_level=self._determine_risk_level(cvss_score),
                affected_versions=["*"],
                reference_urls=[
                    f"https://nvd.nist.gov/vuln/search/results?form_type=Advanced&cves=on&cpe_version=cpe:/a:{service.name}",
                    "https://www.cvedetails.com/vulnerability-list/"
                ],
                fix_suggestions=f"1. Update {service.name} to the latest version\n2. Apply security patches\n3. Implement network segmentation\n4. Use strong authentication"
            )
            vulnerabilities.append(vulnerability)

        # If we have version information, add version-specific vulnerabilities
        if service.version:
            try:
                async with aiohttp.ClientSession() as session:
                    params = {
                        "keywordSearch": f"{service.name} {service.version}",
                        "resultsPerPage": 10  # Increased from 5
                    }
                    if self.nvd_api_key:
                        params["apiKey"] = self.nvd_api_key

                    async with session.get(self.base_url, params=params) as response:
                        if response.status == 200:
                            data = await response.json()
                            for vuln in data.get("vulnerabilities", []):
                                cve = vuln.get("cve", {})
                                metrics = cve.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {})
                                
                                base_score = float(metrics.get("baseScore", 7.5))  # Increased default score
                                vulnerability = Vulnerability(
                                    cve_id=cve.get("id", "UNKNOWN"),
                                    description=f"{service.name} {service.version}: {cve.get('descriptions', [{}])[0].get('value', 'Potential security vulnerability')}",
                                    cvss_score=base_score,
                                    risk_level=self._determine_risk_level(base_score),
                                    affected_versions=[service.version],
                                    reference_urls=[ref.get("url") for ref in cve.get("references", [])],
                                    fix_suggestions="1. Update to the latest version\n2. Apply security patches\n3. Monitor for suspicious activity"
                                )
                                vulnerabilities.append(vulnerability)
            except Exception as e:
                logger.error(f"Error fetching vulnerabilities from NVD: {str(e)}")

        return vulnerabilities

    def _extract_version_components(self, version: str) -> tuple:
        """Extract major, minor, patch versions from version string"""
        if not version:
            return (None, None, None)
        # Handle various version formats
        match = re.search(r'(\d+)(?:\.(\d+))?(?:\.(\d+))?', version)
        if match:
            return tuple(int(v) if v else None for v in match.groups())
        return (None, None, None)

    def _version_is_affected(self, current_version: str, affected_version: str) -> bool:
        """Check if current version is affected by vulnerability"""
        if not current_version or not affected_version:
            return True  # Assume vulnerable if version info is missing
        
        current = self._extract_version_components(current_version)
        affected = self._extract_version_components(affected_version)
        
        # Compare version components
        for curr, aff in zip(current, affected):
            if curr is None or aff is None:
                return True  # Assume vulnerable if component is missing
            if curr < aff:
                return True
            if curr > aff:
                return False
        return True

    def _get_common_vulnerabilities(self, service: Service) -> List[Vulnerability]:
        """Get common vulnerabilities based on port number and service"""
        vulnerabilities = []
        port_vulns = self.common_vulnerabilities.get(service.port, [])
        
        for vuln_desc, cvss_score in port_vulns:
            vulnerabilities.append(
                Vulnerability(
                    cve_id=f"COMMON-{service.port}-{hash(vuln_desc) % 1000:03d}",
                    description=f"{vuln_desc} potentially affecting {service.name} on port {service.port}",
                    cvss_score=cvss_score,
                    risk_level=self._determine_risk_level(cvss_score),
                    affected_versions=["*"],
                    fix_suggestions=f"Secure {service.name} configuration and apply latest security patches",
                    reference_urls=["https://nvd.nist.gov", "https://cve.mitre.org"]
                )
            )
        return vulnerabilities

    async def get_vulnerabilities(self, service: Service) -> List[Vulnerability]:
        """
        Query NVD database for vulnerabilities related to the service and combine with common vulnerabilities
        """
        logger.info(f"Starting vulnerability scan for service: {service.name} on port {service.port}")
        vulnerabilities = []
        
        # Add common vulnerabilities based on port
        common_vulns = self._get_common_vulnerabilities(service)
        logger.info(f"Found {len(common_vulns)} common vulnerabilities for port {service.port}")
        vulnerabilities.extend(common_vulns)

        if not service.name or service.name == "unknown":
            logger.warning(f"Service name unknown for port {service.port}, skipping NVD lookup")
            return vulnerabilities

        try:
            async with aiohttp.ClientSession() as session:
                # Multiple search queries for better coverage
                search_queries = [
                    service.name,  # Basic service name
                    f"{service.name} {service.version}" if service.version else None,  # With version
                    f"{service.name} remote code execution",  # Common critical vulns
                    f"{service.name} privilege escalation",
                    f"{service.name} buffer overflow",
                    f"{service.name} authentication bypass"
                ]

                logger.info(f"Using search queries: {[q for q in search_queries if q]}")

                headers = {
                    "apiKey": self.nvd_api_key
                } if self.nvd_api_key else {}

                for query in search_queries:
                    if not query:
                        continue

                    params = {
                        "keywordSearch": query,
                        "resultsPerPage": 100  # Increased for better coverage
                    }

                    try:
                        logger.info(f"Querying NVD with: {query}")
                        async with session.get(
                            self.base_url,
                            headers=headers,
                            params=params
                        ) as response:
                            if response.status == 200:
                                data = await response.json()
                                vulns = data.get("vulnerabilities", [])
                                logger.info(f"Found {len(vulns)} vulnerabilities for query: {query}")
                                
                                for vuln in vulns:
                                    cve = vuln.get("cve", {})
                                    metrics = cve.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {})
                                    
                                    # Get CVSS score, default to 5.0 if not available
                                    cvss_score = metrics.get("baseScore", 5.0)
                                    
                                    # Extract affected versions from descriptions
                                    descriptions = cve.get("descriptions", [])
                                    description = next((d["value"] for d in descriptions if d["lang"] == "en"), "No description available")
                                    
                                    # Extract references
                                    references = cve.get("references", [])
                                    reference_urls = [ref.get("url") for ref in references if ref.get("url")]
                                    
                                    vulnerabilities.append(
                                        Vulnerability(
                                            cve_id=cve.get("id", "UNKNOWN"),
                                            description=description,
                                            cvss_score=cvss_score,
                                            risk_level=self._determine_risk_level(cvss_score),
                                            affected_versions=["*"],  # Assume all versions affected for maximum coverage
                                            fix_suggestions=f"Update {service.name} to the latest version and apply security patches",
                                            reference_urls=reference_urls[:5]  # Limit to 5 references
                                        )
                                    )
                            else:
                                logger.error(f"NVD API returned status {response.status} for query: {query}")
                                response_text = await response.text()
                                logger.error(f"Response: {response_text}")
                    except Exception as e:
                        logger.error(f"Error querying NVD for {query}: {str(e)}")
                        continue

        except Exception as e:
            logger.error(f"Error in vulnerability scanning: {str(e)}")
        
        # Remove duplicates based on CVE ID
        seen_cves = set()
        unique_vulnerabilities = []
        for vuln in vulnerabilities:
            if vuln.cve_id not in seen_cves:
                seen_cves.add(vuln.cve_id)
                unique_vulnerabilities.append(vuln)

        logger.info(f"Final vulnerability count for {service.name}:{service.port} - Total: {len(vulnerabilities)}, Unique: {len(unique_vulnerabilities)}")
        return unique_vulnerabilities
