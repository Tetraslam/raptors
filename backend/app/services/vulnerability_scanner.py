import aiohttp
import logging
from typing import List, Dict, Optional
from ..models import Service, Vulnerability, RiskLevel
import json
import os
import re
import openai
from ..config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class VulnerabilityScanner:
    def __init__(self):
        self.nvd_api_key = os.getenv("NVD_API_KEY", "")
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.client = openai.AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        # Enhanced vulnerabilities database with more critical issues
        self.common_vulnerabilities = {
            21: [
                ("Critical FTP vulnerability allowing anonymous access", 9.8),
                ("FTP bounce attack vulnerability", 8.5),
                ("FTP brute force susceptibility", 7.2)
            ],
            22: [
                ("SSH weak cipher vulnerability", 9.1),
                ("SSH brute force susceptibility", 7.5),
                ("OpenSSH pre-auth remote code execution", 9.8)
            ],
            80: [
                ("Remote code execution via HTTP", 9.8),
                ("SQL injection vulnerability", 9.1),
                ("Cross-site scripting (XSS)", 8.2),
                ("Directory traversal", 7.5),
                ("File inclusion vulnerability", 8.8)
            ],
            443: [
                ("SSL/TLS critical vulnerability", 9.8),
                ("Heartbleed vulnerability", 9.0),
                ("POODLE attack vulnerability", 8.3),
                ("BEAST attack susceptibility", 7.4)
            ],
            445: [
                ("EternalBlue SMB vulnerability", 9.9),
                ("SMBGhost remote code execution", 9.8),
                ("SMB relay attack vulnerability", 8.8),
                ("SMB brute force susceptibility", 7.5)
            ],
            1433: [
                ("SQL Server remote code execution", 9.9),
                ("SQL Server authentication bypass", 9.1),
                ("Weak password policy", 7.5)
            ],
            3000: [
                ("Node.js remote code execution", 9.8),
                ("Authentication bypass vulnerability", 9.1),
                ("Cross-site scripting (XSS)", 8.2),
                ("SQL injection vulnerability", 8.8)
            ],
            3389: [
                ("BlueKeep RDP vulnerability", 9.9),
                ("RDP remote code execution", 9.8),
                ("Man-in-the-middle susceptibility", 8.5)
            ],
            8000: [
                ("Web server remote code execution", 9.8),
                ("Authentication bypass", 9.1),
                ("Directory traversal", 8.5),
                ("Information disclosure", 7.8)
            ]
        }
        # Add default vulnerabilities for unknown ports
        self.default_vulnerabilities = [
            ("Potential remote code execution", 8.9),
            ("Authentication bypass", 8.5),
            ("Information disclosure", 7.2)
        ]

    def _determine_risk_level(self, cvss_score: float) -> RiskLevel:
        if cvss_score >= 8.5:
            return RiskLevel.CRITICAL
        elif cvss_score >= 6.5:
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW

    async def _get_ai_fix_suggestions(self, vulnerability_data: Dict) -> str:
        """Get AI-powered fix suggestions using GPT-4"""
        try:
            # Create a detailed prompt based on the vulnerability data
            messages = [
                {
                    "role": "system",
                    "content": "You are a cybersecurity expert. Provide specific, actionable fix suggestions for the vulnerability. Focus on technical details and exact steps."
                },
                {
                    "role": "user",
                    "content": f"""Analyze this specific vulnerability and provide detailed remediation steps:

Service: {vulnerability_data.get('service_name', 'Unknown')}
Port: {vulnerability_data.get('port', 'Unknown')}
CVE ID: {vulnerability_data.get('cve_id', 'N/A')}
Vulnerability: {vulnerability_data.get('description', 'No description available')}
CVSS Score: {vulnerability_data.get('cvss_score', 'Unknown')}

Format your response as follows:
1. IMMEDIATE ACTIONS:
[List specific commands, configuration changes, or immediate steps to mitigate]

2. LONG-TERM FIXES:
[List architectural changes, upgrades, or strategic improvements]

3. VERIFICATION STEPS:
[List specific commands or procedures to verify the fix]

4. ADDITIONAL SECURITY MEASURES:
[List complementary security controls specific to this vulnerability]

Be specific to this exact vulnerability. Include exact commands, configuration file locations, and settings where applicable."""
                }
            ]

            response = await self.client.chat.completions.create(
                model="gpt-4",
                messages=messages,
                temperature=0.2,
                max_tokens=750
            )

            return response.choices[0].message.content

        except Exception as e:
            logger.error(f"Error getting AI fix suggestions: {str(e)}")
            # Provide a more specific fallback message based on the vulnerability type
            if "SQL" in vulnerability_data.get('description', ''):
                return ("1. Review and sanitize all SQL queries\n"
                       "2. Implement parameterized queries\n"
                       "3. Use an ORM when possible\n"
                       "4. Regular security audits of database access")
            elif "XSS" in vulnerability_data.get('description', ''):
                return ("1. Implement input validation\n"
                       "2. Use content security policy headers\n"
                       "3. Sanitize all user inputs\n"
                       "4. Regular security testing")
            else:
                return ("1. Update to the latest secure version\n"
                       "2. Apply all security patches\n"
                       "3. Monitor logs for suspicious activity\n"
                       "4. Implement defense in depth")

    def _get_nvd_reference_urls(self, service: Service, cve_id: Optional[str] = None) -> List[str]:
        """Generate proper NVD reference URLs"""
        urls = []
        
        # Convert service name to CPE format (lowercase, no spaces)
        cpe_name = service.name.lower().replace(" ", "_")
        
        if cve_id and cve_id.startswith("CVE-"):
            # If we have a CVE ID, link directly to it
            urls.append(f"https://nvd.nist.gov/vuln/detail/{cve_id}")
        
        # Add CPE-based search URL with correct format
        # Format: cpe:/part:vendor:product:version
        cpe_version = f"cpe:/a:{cpe_name}:{cpe_name}"
        urls.append(f"https://nvd.nist.gov/vuln/search/results?adv_search=true&cpe_version={cpe_version}")
        
        # Add CVEDetails URL if we have a CVE ID
        if cve_id and cve_id.startswith("CVE-"):
            urls.append(f"https://www.cvedetails.com/cve/{cve_id}")
        
        return urls

    async def scan_service(self, service: Service) -> List[Vulnerability]:
        """Scan a service for known vulnerabilities"""
        vulnerabilities = []
        
        # Get vulnerabilities list for the port or use defaults
        port_vulns = self.common_vulnerabilities.get(service.port, self.default_vulnerabilities)
        
        # Add port-specific vulnerabilities
        for vuln_desc, cvss_score in port_vulns:
            vulnerability_data = {
                'service_name': service.name,
                'port': service.port,
                'cve_id': f"VULN-{service.port}-{hash(vuln_desc) % 1000:03d}",
                'description': f"{service.name} ({service.port}/tcp): {vuln_desc}",
                'cvss_score': cvss_score
            }
            
            # Get AI-powered fix suggestions
            fix_suggestions = await self._get_ai_fix_suggestions(vulnerability_data)
            
            vulnerability = Vulnerability(
                cve_id=vulnerability_data['cve_id'],
                description=vulnerability_data['description'],
                cvss_score=cvss_score,
                risk_level=self._determine_risk_level(cvss_score),
                affected_versions=["*"],
                reference_urls=self._get_nvd_reference_urls(service),
                fix_suggestions=fix_suggestions
            )
            vulnerabilities.append(vulnerability)

        # If we have version information, add version-specific vulnerabilities
        if service.version:
            try:
                async with aiohttp.ClientSession() as session:
                    params = {
                        "keywordSearch": f"{service.name} {service.version}",
                        "resultsPerPage": 10
                    }
                    if self.nvd_api_key:
                        params["apiKey"] = self.nvd_api_key

                    async with session.get(self.base_url, params=params) as response:
                        if response.status == 200:
                            data = await response.json()
                            for vuln in data.get("vulnerabilities", []):
                                cve = vuln.get("cve", {})
                                metrics = cve.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {})
                                
                                base_score = float(metrics.get("baseScore", 7.5))
                                cve_id = cve.get("id")
                                
                                vulnerability_data = {
                                    'service_name': service.name,
                                    'port': service.port,
                                    'cve_id': cve_id,
                                    'description': cve.get('descriptions', [{}])[0].get('value', 'Potential security vulnerability'),
                                    'cvss_score': base_score
                                }
                                
                                # Get AI-powered fix suggestions
                                fix_suggestions = await self._get_ai_fix_suggestions(vulnerability_data)
                                
                                # Get reference URLs including direct CVE links
                                reference_urls = self._get_nvd_reference_urls(service, cve_id)
                                # Add any additional references from the CVE
                                reference_urls.extend([ref.get("url") for ref in cve.get("references", []) if ref.get("url")])
                                
                                vulnerability = Vulnerability(
                                    cve_id=vulnerability_data['cve_id'],
                                    description=f"{service.name} {service.version}: {vulnerability_data['description']}",
                                    cvss_score=base_score,
                                    risk_level=self._determine_risk_level(base_score),
                                    affected_versions=[service.version],
                                    reference_urls=reference_urls,
                                    fix_suggestions=fix_suggestions
                                )
                                vulnerabilities.append(vulnerability)
            except Exception as e:
                logger.error(f"Error fetching vulnerabilities from NVD: {str(e)}")

        return vulnerabilities

    def _extract_version_components(self, version: str) -> tuple:
        """Extract major, minor, patch versions from version string"""
        if not version:
            return (None, None, None)
        # Handle various version formats
        match = re.search(r'(\d+)(?:\.(\d+))?(?:\.(\d+))?', version)
        if match:
            return tuple(int(v) if v else None for v in match.groups())
        return (None, None, None)

    def _version_is_affected(self, current_version: str, affected_version: str) -> bool:
        """Check if current version is affected by vulnerability"""
        if not current_version or not affected_version:
            return True  # Assume vulnerable if version info is missing
        
        current = self._extract_version_components(current_version)
        affected = self._extract_version_components(affected_version)
        
        # Compare version components
        for curr, aff in zip(current, affected):
            if curr is None or aff is None:
                return True  # Assume vulnerable if component is missing
            if curr < aff:
                return True
            if curr > aff:
                return False
        return True

    def _get_common_vulnerabilities(self, service: Service) -> List[Vulnerability]:
        """Get common vulnerabilities based on port number and service"""
        vulnerabilities = []
        port_vulns = self.common_vulnerabilities.get(service.port, [])
        
        for vuln_desc, cvss_score in port_vulns:
            vulnerabilities.append(
                Vulnerability(
                    cve_id=f"COMMON-{service.port}-{hash(vuln_desc) % 1000:03d}",
                    description=f"{vuln_desc} potentially affecting {service.name} on port {service.port}",
                    cvss_score=cvss_score,
                    risk_level=self._determine_risk_level(cvss_score),
                    affected_versions=["*"],
                    fix_suggestions=f"Secure {service.name} configuration and apply latest security patches",
                    reference_urls=["https://nvd.nist.gov", "https://cve.mitre.org"]
                )
            )
        return vulnerabilities

    async def get_vulnerabilities(self, service: Service) -> List[Vulnerability]:
        """
        Query NVD database for vulnerabilities related to the service and combine with common vulnerabilities
        """
        logger.info(f"Starting vulnerability scan for service: {service.name} on port {service.port}")
        vulnerabilities = []
        
        # Add common vulnerabilities based on port
        common_vulns = self._get_common_vulnerabilities(service)
        logger.info(f"Found {len(common_vulns)} common vulnerabilities for port {service.port}")
        vulnerabilities.extend(common_vulns)

        if not service.name or service.name == "unknown":
            logger.warning(f"Service name unknown for port {service.port}, skipping NVD lookup")
            return vulnerabilities

        try:
            async with aiohttp.ClientSession() as session:
                # Multiple search queries for better coverage
                search_queries = [
                    service.name,  # Basic service name
                    f"{service.name} {service.version}" if service.version else None,  # With version
                    f"{service.name} remote code execution",  # Common critical vulns
                    f"{service.name} privilege escalation",
                    f"{service.name} buffer overflow",
                    f"{service.name} authentication bypass"
                ]

                logger.info(f"Using search queries: {[q for q in search_queries if q]}")

                headers = {
                    "apiKey": self.nvd_api_key
                } if self.nvd_api_key else {}

                for query in search_queries:
                    if not query:
                        continue

                    params = {
                        "keywordSearch": query,
                        "resultsPerPage": 100
                    }

                    try:
                        logger.info(f"Querying NVD with: {query}")
                        async with session.get(
                            self.base_url,
                            headers=headers,
                            params=params
                        ) as response:
                            if response.status == 200:
                                data = await response.json()
                                vulns = data.get("vulnerabilities", [])
                                logger.info(f"Found {len(vulns)} vulnerabilities for query: {query}")
                                
                                for vuln in vulns:
                                    cve = vuln.get("cve", {})
                                    metrics = cve.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {})
                                    
                                    # Get CVSS score, default to 5.0 if not available
                                    cvss_score = metrics.get("baseScore", 5.0)
                                    
                                    # Extract affected versions from descriptions
                                    descriptions = cve.get("descriptions", [])
                                    description = next((d["value"] for d in descriptions if d["lang"] == "en"), "No description available")
                                    
                                    # Extract references
                                    references = cve.get("references", [])
                                    reference_urls = [ref.get("url") for ref in references if ref.get("url")]
                                    
                                    vulnerability_data = {
                                        'service_name': service.name,
                                        'port': service.port,
                                        'cve_id': cve.get("id", "UNKNOWN"),
                                        'description': description,
                                        'cvss_score': cvss_score
                                    }
                                    
                                    # Get AI-powered fix suggestions
                                    fix_suggestions = await self._get_ai_fix_suggestions(vulnerability_data)
                                    
                                    vulnerabilities.append(
                                        Vulnerability(
                                            cve_id=vulnerability_data['cve_id'],
                                            description=description,
                                            cvss_score=cvss_score,
                                            risk_level=self._determine_risk_level(cvss_score),
                                            affected_versions=["*"],  # Assume all versions affected for maximum coverage
                                            fix_suggestions=fix_suggestions,
                                            reference_urls=reference_urls[:5]  # Limit to 5 references
                                        )
                                    )
                            else:
                                logger.error(f"NVD API returned status {response.status} for query: {query}")
                                response_text = await response.text()
                                logger.error(f"Response: {response_text}")
                    except Exception as e:
                        logger.error(f"Error querying NVD for {query}: {str(e)}")
                        continue

        except Exception as e:
            logger.error(f"Error in vulnerability scanning: {str(e)}")
        
        # Remove duplicates based on CVE ID
        seen_cves = set()
        unique_vulnerabilities = []
        for vuln in vulnerabilities:
            if vuln.cve_id not in seen_cves:
                seen_cves.add(vuln.cve_id)
                unique_vulnerabilities.append(vuln)

        logger.info(f"Final vulnerability count for {service.name}:{service.port} - Total: {len(vulnerabilities)}, Unique: {len(unique_vulnerabilities)}")
        return unique_vulnerabilities
